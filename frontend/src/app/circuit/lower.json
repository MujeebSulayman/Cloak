{
    "noir_version": "1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663",
    "hash": "6101675327084761513",
    "abi": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "kind": "array",
            "length": 50,
            "type": {
              "kind": "array",
              "length": 32,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          },
          "visibility": "private"
        },
        {
          "name": "size",
          "type": { "kind": "integer", "sign": "unsigned", "width": 32 },
          "visibility": "private"
        },
        {
          "name": "leaf_hash",
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "public"
        },
        {
          "name": "pairwise_value_bytes",
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "public"
        },
        {
          "name": "pub_key_x",
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "private"
        },
        {
          "name": "pub_key_y",
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "private"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "private"
        },
        {
          "name": "hashed_message",
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "private"
        },
        {
          "name": "prover_address",
          "type": {
            "kind": "array",
            "length": 20,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "public"
        },
        {
          "name": "countryparty_address",
          "type": {
            "kind": "array",
            "length": 20,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "public"
        },
        {
          "name": "token_address",
          "type": {
            "kind": "array",
            "length": 20,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "public"
        },
        {
          "name": "key",
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          },
          "visibility": "public"
        }
      ],
      "return_type": null,
      "error_types": {
        "361444214588792908": {
          "error_kind": "string",
          "string": "attempt to multiply with overflow"
        },
        "1998584279744703196": {
          "error_kind": "string",
          "string": "attempt to subtract with overflow"
        },
        "14990209321349310352": {
          "error_kind": "string",
          "string": "attempt to add with overflow"
        },
        "15764276373176857197": {
          "error_kind": "string",
          "string": "Stack too deep"
        },
        "16431471497789672479": {
          "error_kind": "string",
          "string": "Index out of bounds"
        }
      }
    },
    "bytecode": "H4sIAAAAAAAA/+3dBbgUddw+/Dmcw4FDd8ehu7u7u7u7u1tJBQHp7u7uFlFBQrEJsShFFBTFer/zfxi9/Tn3cmLn+/Bc79nrui/x7Gfmnt39zezs7uxsgPU/l6Bn/+3ToUff0TEsK8D4e5xn/7X/Xj7Y+tfFsaFWmC4B4bD/nigcHQGW9x3RLO87Ai3vO4Is7zuiW953BFved8SwvO+IaXnfEWJ53xHL8r4jtuV9RxzL+464lvcd8SzvO+Jb3ncksLzvSGh535HI8r4jseV9RxLL+46klvcdySzvO5Jb3neksLzvSGl535HK8r4jteV9RxrL+460lvcd6SzvO9Jb3neEWt53ZLC878hoed+RyfK+I7PlfUcWy/uOrJb3Hdks7zuyW9535LC878hped+Ry/K+I7flfUcey/uOvJb3Hfks7zvyW953FLC87yhoed9RyPK+o7DlfUcRy/uOopb3HcUs7zuKW953lLC87yhped9RyvK+o7TlfUcZy/uOspb3HeUs7zvKW953VLC876hoed9RyfK+o7LlfUcVy/uOqpb3HdUs7zuqW9531LC876hped9Ry/K+o7blfUcdy/uOupb3HfUs7zvqW953NLC872hoed/RyPK+o7HlfUcTy/uOppb3Hc0s7zuaW953tLC872hped/RyvK+o7XlfUcby/uOtpb3He0s7zvaW953dLC87+hoed/RyfK+o7PlfUcXy/uOrpb3Hd0s7zu6W9539LC87+hped/Ry/K+o7flfUcfy/uOvpb3Hf0s7zv6W953DLC87xhoed8xyPK+Y7DlfccQy/uOoZb3HcMs7zuGW953jLC87xhped8xyvK+Y7TlfccYy/uOsZb3HeMs7zvGW953TLC873jJ8r7jZcv7jomW9x2TLO87Jlved0yxvO+YannfMc3yvuMVy/uOVy3vO6Zb3nfMsLzveM3yvmOm5X3HLMv7jtmW9x2vW953zLG875hred8xz/K+Y77lfccCy/uOhZb3HYss7zsWW953LLG871hqed+xzPK+Y7nlfccKy/uOlZb3Hass7ztWW953rLG871hred+xzvK+Y73lfccGy/uOjZb3HZss7zs2W953bLG879hqed+xzfK+Y7vlfccOy/uOnZb3Hbss7zt2W9537LG879hred+xz/K+Y7/lfccBy/uOg5b3HYcs7zsOW953HLG8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",
    "debug_symbols": "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",
    "file_map": {
      "5": {
        "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n",
        "path": "std/cmp.nr"
      },
      "18": {
        "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n",
        "path": "std/field/mod.nr"
      },
      "19": {
        "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
        "path": "std/hash/mod.nr"
      },
      "22": {
        "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n",
        "path": "std/lib.nr"
      },
      "50": {
        "source": "fn add256(a: [u8; 32], b: [u8; 32]) -> [u8; 32] {\n    let mut res: [u8; 32] = [0; 32];\n    let mut carry: u16 = 0;\n    for i in 0..32 {\n        let sum: u16 = carry + a[i] as u16 + b[i] as u16;\n        res[i] = (sum & 0xFF) as u8;\n        carry = sum >> 8;\n    }\n    res\n}\n\nfn sub256(a: [u8; 32], b: [u8; 32]) -> [u8; 32] {\n    let mut res: [u8; 32] = [0; 32];\n    let mut borrow: i16 = 0;\n    for i in 0..32 {\n        let diff: i16 = a[i] as i16 - b[i] as i16 - borrow;\n        if diff < 0 {\n            res[i] = (diff + 256) as u8;\n            borrow = 1;\n        } else {\n            res[i] = diff as u8;\n            borrow = 0;\n        }\n    }\n    res\n}\n\nfn mul256(a: [u8; 32], b: [u8; 32]) -> [u8; 32] {\n    let mut tmp: [u32; 64] = [0; 64];\n\n    for i in 0..32 {\n        for j in 0..32 {\n            tmp[i + j] = tmp[i + j] + (a[i] as u32) * (b[j] as u32);\n        }\n    }\n\n    let mut res: [u8; 32] = [0; 32];\n    let mut carry: u32 = 0;\n    for k in 0..32 {\n        let sum: u32 = tmp[k] + carry;\n        res[k] = (sum & 0xFF) as u8;\n        carry = sum >> 8;\n    }\n    res\n}\n\nuse std::cmp::{Eq, Ord, Ordering};\nuse std::ops::{Add, Mul, Sub};\n\npub struct U256Bytes {\n    pub limbs: [u8; 32],\n}\n\nimpl U256Bytes {\n    pub fn new(limbs: [u8; 32]) -> Self {\n        U256Bytes { limbs }\n    }\n\n    pub fn zero() -> Self {\n        U256Bytes { limbs: [0; 32] }\n    }\n}\n\nimpl Add for U256Bytes {\n    fn add(self, other: U256Bytes) -> U256Bytes {\n        U256Bytes { limbs: add256(self.limbs, other.limbs) }\n    }\n}\n\nimpl Sub for U256Bytes {\n    fn sub(self, other: U256Bytes) -> U256Bytes {\n        U256Bytes { limbs: sub256(self.limbs, other.limbs) }\n    }\n}\n\nimpl Mul for U256Bytes {\n    fn mul(self, other: U256Bytes) -> U256Bytes {\n        U256Bytes { limbs: mul256(self.limbs, other.limbs) }\n    }\n}\n\nimpl Eq for U256Bytes {\n    fn eq(self, other: U256Bytes) -> bool {\n        let mut is_eq: bool = true;\n        for i in 0..32 {\n            is_eq = is_eq & (self.limbs[i] == other.limbs[i]);\n        }\n        is_eq\n    }\n}\n\nimpl Ord for U256Bytes {\n    fn cmp(self, other: U256Bytes) -> Ordering {\n        let mut less_flag: bool = false;\n        let mut greater_flag: bool = false;\n        let mut prefix_equal: bool = true;\n\n        for i in 0..32 {\n            let a = self.limbs[i];\n            let b = other.limbs[i];\n            let eq = a == b;\n            let lt = a < b;\n            let gt = a > b;\n\n            less_flag = less_flag | (prefix_equal & lt);\n            greater_flag = greater_flag | (prefix_equal & gt);\n            prefix_equal = prefix_equal & eq;\n        }\n\n        if greater_flag {\n            Ordering::greater()\n        } else if less_flag {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
        "path": "/Users/ataberkcekic/main-code/projects/ethglobal-buenos-void/circuits/lower/src/U256.nr"
      },
      "51": {
        "source": "mod U256;\nuse keccak256::keccak256;\nuse prove_transfer_key;\nuse U256::U256Bytes;\n\nunconstrained fn main(\n    value: [[u8; 32]; 50],\n    size: u32,\n    leaf_hash: pub [u8; 32],\n    pairwise_value_bytes: pub [u8; 32],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32],\n    prover_address: pub [u8; 20],\n    countryparty_address: pub [u8; 20],\n    token_address: pub [u8; 20],\n    key: pub [u8; 32],\n) {\n    prove_transfer_key::check_key(\n        pub_key_x,\n        pub_key_y,\n        signature,\n        hashed_message,\n        prover_address,\n        countryparty_address,\n        token_address,\n        key,\n    );\n\n    let pairwise_value = U256Bytes::new(pairwise_value_bytes);\n    let mut concatenated: [u8; 1664] = [0; 1664]; // 50 * 32 = 1600 max\n    let mut offset = 0;\n\n    // Add the key (32 bytes)\n    for i in 0..32 {\n        concatenated[offset] = key[i];\n        offset += 1;\n    }\n\n    // Add all values (size * 32 bytes)\n    for i in 0..size {\n        for j in 0..32 {\n            concatenated[offset] = value[i][j];\n            offset += 1;\n        }\n    }\n    // Add pairwise_value at the current offset (where data actually ends)\n    for i in 0..31 {\n        concatenated[offset] = 0;\n        offset += 1;\n    }\n    concatenated[offset] = 1;\n\n    let calc_leaf_hash = keccak256(concatenated, size * 32 + 64);\n\n    //assert(leaf_hash == calc_leaf_hash);\n\n    for i in 0..50 {\n        let value_bytes = U256Bytes::new(value[i]);\n        assert(value_bytes <= pairwise_value);\n    }\n}\n\n#[test]\nunconstrained fn test_main() {\n    let pub_key_x: [u8; 32] = [\n        167, 1, 227, 30, 163, 41, 124, 31, 117, 98, 23, 40, 211, 128, 235, 52, 55, 130, 211, 115,\n        100, 28, 72, 115, 14, 141, 40, 171, 136, 112, 19, 31,\n    ];\n    let pub_key_y: [u8; 32] = [\n        251, 52, 202, 67, 50, 87, 144, 123, 171, 75, 185, 162, 4, 41, 143, 107, 237, 205, 91, 126,\n        204, 21, 18, 34, 246, 186, 200, 210, 219, 216, 248, 60,\n    ];\n\n    let signature: [u8; 64] = [\n        115, 155, 191, 76, 93, 103, 244, 224, 84, 203, 224, 196, 214, 244, 224, 144, 133, 152, 114,\n        128, 24, 57, 60, 0, 241, 88, 184, 77, 33, 179, 168, 18, 51, 141, 73, 214, 178, 89, 21, 45,\n        141, 57, 212, 159, 231, 240, 64, 56, 94, 16, 193, 69, 191, 117, 48, 40, 192, 254, 56, 74,\n        50, 215, 247, 50,\n    ];\n    let hashed_message: [u8; 32] = [\n        90, 251, 82, 21, 213, 152, 102, 181, 33, 69, 247, 117, 204, 190, 24, 141, 126, 186, 230,\n        132, 148, 157, 220, 87, 254, 242, 206, 153, 206, 52, 177, 205,\n    ];\n\nlet prover_address: [u8; 20] = [\n    0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3, \n    0x38, 0xd6, 0xE4, 0xcf, 0x48,\n];\n\nlet counterparty_address: [u8; 20] = [\n    0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3, \n    0x38, 0xd6, 0xE4, 0xcf, 0x48,\n];\n\n    let token_address: [u8; 20] = [\n        0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3,\n        0x38, 0xd6, 0xE4, 0xcf, 0x48,\n    ];\n\n\n    let key: [u8; 32] = [ 46, 133, 225, 23, 62, 168, 20, 185, 219, 173, 50, 162, 27, 6, 69, 43, 245, 69, 178, 171, 243, 237, 204, 66, 209, 40, 106, 23, 215, 160, 139, 151 ];\n\n    let mut value_array: [[u8; 32]; 50] = [[0; 32]; 50];\n    let size: u32 = 10;\n\n    for i in 0..size {\n        let num = ((i + 1) * 5) as u8;\n        value_array[i][31] = num;\n    }\n\n    // Calculate leaf hash\n    let mut concatenated: [u8; 384] = [0; 384];\n    let mut offset = 0;\n\n    // Add the key (32 bytes)\n    for i in 0..32 {\n        concatenated[offset] = key[i];\n        offset += 1;\n    }\n\n    // Add all values (size * 32 bytes)\n    for i in 0..size {\n        for j in 0..32 {\n            concatenated[offset] = value_array[i][j];\n            offset += 1;\n        }\n    }\n    // Add pairwise_value at the current offset (where data actually ends)\n    for i in 0..31 {\n        concatenated[offset] = 0;\n        offset += 1;\n    }\n    concatenated[offset] = 1;\n\n    let leaf_hash = keccak256(concatenated, size * 32 + 64);\n\n    std::println(concatenated);\n\n    std::println(leaf_hash);\n\n    let mut pairwise = [0; 32];\n    pairwise[31] = 255;\n\n    main(\n        value_array,\n        size,\n        leaf_hash,\n        pairwise,\n        pub_key_x,\n        pub_key_y,\n        signature,\n        hashed_message,\n        prover_address,\n        counterparty_address,\n        token_address,\n        key,\n    );\n\n    std::println(\"Test passed! Main function executed successfully.\");\n}\n\n#[test(should_fail)]\nunconstrained fn test_main_fail() {\n    let pub_key_x: [u8; 32] = [\n        167, 1, 227, 30, 163, 41, 124, 31, 117, 98, 23, 40, 211, 128, 235, 52, 55, 130, 211, 115,\n        100, 28, 72, 115, 14, 141, 40, 171, 136, 112, 19, 31,\n    ];\n    let pub_key_y: [u8; 32] = [\n        251, 52, 202, 67, 50, 87, 144, 123, 171, 75, 185, 162, 4, 41, 143, 107, 237, 205, 91, 126,\n        204, 21, 18, 34, 246, 186, 200, 210, 219, 216, 248, 60,\n    ];\n    let signature: [u8; 64] = [\n        8, 73, 204, 13, 170, 75, 221, 0, 62, 119, 11, 118, 218, 224, 212, 118, 163, 169, 83, 28,\n        252, 29, 69, 197, 121, 156, 98, 89, 80, 231, 83, 208, 126, 33, 213, 114, 247, 220, 68, 27,\n        149, 159, 61, 68, 72, 115, 183, 188, 178, 221, 97, 126, 243, 18, 240, 169, 58, 225, 176,\n        190, 136, 11, 235, 131,\n    ];\n    let hashed_message: [u8; 32] = [\n        235, 253, 109, 103, 213, 171, 112, 7, 135, 149, 110, 64, 159, 142, 173, 12, 99, 196, 92,\n        127, 202, 100, 111, 76, 147, 181, 13, 170, 219, 39, 18, 61,\n    ];\n\nlet prover_address: [u8; 20] = [\n    0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3, \n    0x38, 0xd6, 0xE4, 0xcf, 0x48,\n];\n\nlet counterparty_address: [u8; 20] = [\n    0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3, \n    0x38, 0xd6, 0xE4, 0xcf, 0x48,\n];\n\n    let token_address: [u8; 20] = [\n        0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3,\n        0x38, 0xd6, 0xE4, 0xcf, 0x48,\n    ];\n\n    let key: [u8; 32] = [ 46, 133, 225, 23, 62, 168, 20, 185, 219, 173, 50, 162, 27, 6, 69, 43, 245, 69, 178, 171, 243, 237, 204, 66, 209, 40, 106, 23, 215, 160, 139, 151 ];\n\n    // Setup value array with larger values\n    let mut value_array: [[u8; 32]; 50] = [[0; 32]; 50];\n    let size: u32 = 15;\n\n    for i in 0..size {\n        let num = ((i + 1) * 10) as u8;\n        value_array[i][31] = num;\n    }\n\n    // Calculate leaf hash\n    let mut concatenated: [u8; 480] = [0; 480]; // 15 * 32\n    let mut offset = 0;\n\n    for i in 0..size {\n        for j in 0..32 {\n            concatenated[offset] = value_array[i][j];\n            offset += 1;\n        }\n    }\n\n    let leaf_hash = keccak256(concatenated, size * 32);\n\n    // Setup pairwise value that's too small (will cause failure)\n    let mut pairwise = [0; 32];\n    pairwise[31] = 100;\n\n    // Call main - should fail because some values exceed pairwise limit\n    main(\n        value_array,\n        size,\n        leaf_hash,\n        pairwise,\n        pub_key_x,\n        pub_key_y,\n        signature,\n        hashed_message,\n        prover_address,\n        counterparty_address,\n        token_address,\n        key,\n    );\n}\n",
        "path": "/Users/ataberkcekic/main-code/projects/ethglobal-buenos-void/circuits/lower/src/main.nr"
      },
      "53": {
        "source": "mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n",
        "path": "/Users/ataberkcekic/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"
      },
      "63": {
        "source": "use dep::std;\n\n// Main library function to compute transaction hash\npub unconstrained fn check_key(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32],\n    prover_address:  [u8; 20],\n    countryparty_address: [u8; 20],\n    token_address: [u8; 20],\n    key: [u8; 32],\n)  {\n    // Recover address from signature\n    //let address = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    \n    // Hash the signature\n    let hash_signature = keccak256::keccak256(signature, 64);\n    \n    // Verify the recovered address matches the prover address\n    //assert_eq(prover_address, field_to_bytes_20(address));\n    \n    // Convert addresses to bytes\n    let prover_addr_bytes = prover_address;\n    let countryparty_addr_bytes = countryparty_address;\n    \n    // Prepare encoded data (92 bytes total)\n    let mut encoded: [u8; 92] = [0; 92];\n    let mut lhs = [0; 20];\n    let mut rhs = [0; 20];\n    \n    // Determine order based on is_send flag\n     lhs = prover_addr_bytes;\n     rhs = countryparty_addr_bytes;\n    \n    // Encode: sender (20) + receiver (20) + token (20) + sig_hash (32)\n    for i in 0..20 {\n        encoded[i] = lhs[i];\n    }\n    for i in 20..40 {\n        encoded[i] = rhs[i - 20];\n    }\n    for i in 0..20 {\n        encoded[40 + i] = token_address[i];\n    }\n    for i in 0..32 {\n        encoded[60 + i] = hash_signature[i];\n    }\n    \n    let final_hash = keccak256::keccak256(encoded, 92);\n    \n    std::println(\"encoded\");\n    std::println(encoded);\n    std::println(\"Test passed! Main function executed successfully.\");\n    std::println(final_hash);\n    std::println(key);\n    assert_eq(final_hash, key);\n}\n\n// Helper function to convert Field to 20 bytes (Ethereum address)\npub unconstrained fn field_to_bytes_20(f: Field) -> [u8; 20] {\n    let bytes = f.to_be_bytes::<32>();\n    let mut result: [u8; 20] = [0; 20];\n    for i in 0..20 {\n        result[i] = bytes[12 + i]; // Take last 20 bytes (160 bits)\n    }\n    result\n}\n\n// Helper function to convert 32 bytes to Field\npub unconstrained fn bytes32_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    for i in 0..32 {\n        result = result * 256 + bytes[i] as Field;\n    }\n    result\n}\n\n#[test]\nunconstrained fn test_compute_check_key() {\n    let pub_key_x: [u8; 32] = [\n        167, 1, 227, 30, 163, 41, 124, 31, 117, 98, 23, 40, 211, 128, 235, 52, 55, 130, 211, 115,\n        100, 28, 72, 115, 14, 141, 40, 171, 136, 112, 19, 31,\n    ];\n\n    let pub_key_y: [u8; 32] = [\n        251, 52, 202, 67, 50, 87, 144, 123, 171, 75, 185, 162, 4, 41, 143, 107, 237, 205, 91, 126,\n        204, 21, 18, 34, 246, 186, 200, 210, 219, 216, 248, 60,\n    ];\n\n    let signature: [u8; 64] = [\n        8, 73, 204, 13, 170, 75, 221, 0, 62, 119, 11, 118, 218, 224, 212, 118, 163, 169, 83, 28,\n        252, 29, 69, 197, 121, 156, 98, 89, 80, 231, 83, 208, 126, 33, 213, 114, 247, 220, 68, 27,\n        149, 159, 61, 68, 72, 115, 183, 188, 178, 221, 97, 126, 243, 18, 240, 169, 58, 225, 176,\n        190, 136, 11, 235, 131,\n    ];\n\n    let hashed_message: [u8; 32] = [\n        235, 253, 109, 103, 213, 171, 112, 7, 135, 149, 110, 64, 159, 142, 173, 12, 99, 196, 92,\n        127, 202, 100, 111, 76, 147, 181, 13, 170, 219, 39, 18, 61,\n    ];\n\nlet prover_address: [u8; 20] = [\n    0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3, \n    0x38, 0xd6, 0xE4, 0xcf, 0x48,\n];\n\nlet counterparty_address: [u8; 20] = [\n    0x3E, 0x00, 0x18, 0x36, 0xe2, 0x40, 0x9f, 0xa0, 0x80, 0x2b, 0x47, 0x3d, 0x00, 0x61, 0xe3, \n    0x38, 0xd6, 0xE4, 0xcf, 0x48,\n];\n\n    let token_address: [u8; 20] = [\n        0xa0, 0xb8, 0x69, 0x91, 0xc6, 0x21, 0x8b, 0x36, 0xc1, 0xd1, 0x9d, 0x4a, 0x2e, 0x9e, 0xb0,\n        0xce, 0x36, 0x06, 0xeb, 0x48,\n    ];\n\n    let key = [ 62, 160, 226, 200, 79, 177, 222, 138, 79, 106, 46, 243, 43, 73, 134, 202, 75, 142, 108, 167, 59, 79, 203, 172, 173, 54, 21, 83, 89, 152, 246, 251 ];\n\n    \n     check_key(\n        pub_key_x,\n        pub_key_y,\n        signature,\n        hashed_message,\n        prover_address,\n        counterparty_address,\n        token_address,\n        key\n    );\n    \n    \n    std::println(\"Test passed! Result hash computed successfully.\");\n}\n",
        "path": "/Users/ataberkcekic/main-code/projects/ethglobal-buenos-void/circuits/prove_transfer_key/src/lib.nr"
      }
    },
    "expression_width": { "Bounded": { "width": 4 } }
  }